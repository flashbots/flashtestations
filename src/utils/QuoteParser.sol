// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {TD10ReportBody} from "automata-dcap-attestation/contracts/types/V4Structs.sol";
import {BytesUtils} from "@automata-network/on-chain-pccs/utils/BytesUtils.sol";
import {TD_REPORT10_LENGTH, TDX_TEE} from "automata-dcap-attestation/contracts/types/Constants.sol";

// User Defined Types

// WorkloadID uniquely identifies a TEE workload. A workload is derived from a combination
// of the TEE's measurement registers. The TDX platform provides several registers that
// capture cryptographic hashes of code, data, and configuration loaded into the TEE's environment.
// This means that whenever a TEE device changes anything about its compute stack (e.g. user code,
// firmware, OS, etc), the workloadID will change.
// See the [Flashtestation's specification](https://github.com/flashbots/rollup-boost/blob/main/specs/flashtestations.md#workload-identity-derivation) for more details
type WorkloadId is bytes32;

/**
 * @title QuoteParser
 * @dev A library for parsing and extracting workload and TEE-controlled address from Automata DCAP Attestation TDX quotes
 */
library QuoteParser {
    using BytesUtils for bytes;

    // Constants

    // The TDX version of the quote Flashtestation's accepts
    uint256 public constant ACCEPTED_TDX_VERSION = 4;

    // The length of the Ethereum uncompressed public key in bytes
    uint256 public constant ETHEREUM_PUBLIC_KEY_LENGTH = 64;

    // This is the number of bytes in the Output struct that come before the quoteBody.
    // See the Output struct definition in the Automata DCAP Attestation repo:
    // https://github.com/automata-network/automata-dcap-attestation/blob/evm-v1.0.0/evm/contracts/types/CommonStruct.sol#L113
    // 13 bytes = quoteVersion (2 bytes) + tee (4 byte) + tcbStatus (1 byte) + fmspcBytes (6 bytes)
    uint256 public constant SERIALIZED_OUTPUT_OFFSET = 13;

    // Errors

    error InvalidTEEType(bytes4 teeType);
    error InvalidTEEVersion(uint16 version);
    error InvalidReportDataLength(uint256 length);

    /**
     * @notice Parses the serialized output of the V4QuoteVerifier into a TD10ReportBody which contains
     * all the data we need for registering a TEE, using the serializedOutput bytes generated by Automata's
     * verification logic
     * @param serializedOutput The serializedOutput bytes generated by Automata's verification logic
     * @return report The parsed TD10ReportBody
     * @dev Taken from Automata's DCAP Attestation repo:
     * https://github.com/automata-network/automata-dcap-attestation/blob/evm-v1.0.0/evm/contracts/verifiers/V4QuoteVerifier.sol#L309
     */
    function parseV4VerifierOutput(bytes memory serializedOutput)
        internal
        pure
        returns (TD10ReportBody memory report)
    {
        // check that now-verified quote is version 4 and of type TDX, otherwise
        // in the next step the output will not have the byte length we expect
        // and we'll fail to parse it, returning a unhelpful error message
        checkTEEVersion(serializedOutput);
        checkTEEType(serializedOutput);

        bytes memory rawReportBody = serializedOutput.substring(SERIALIZED_OUTPUT_OFFSET, TD_REPORT10_LENGTH);

        // note: because of the call to .substring above, we know that the length of rawReportBody is
        // exactly TD_REPORT10_LENGTH, so we can safely call substring without checking the length

        report.teeTcbSvn = bytes16(rawReportBody.substring(0, 16));
        report.mrSeam = rawReportBody.substring(16, 48);
        report.mrsignerSeam = rawReportBody.substring(64, 48);
        report.seamAttributes = bytes8(rawReportBody.substring(112, 8));
        report.tdAttributes = bytes8(rawReportBody.substring(120, 8));
        report.xFAM = bytes8(rawReportBody.substring(128, 8));
        report.mrTd = rawReportBody.substring(136, 48);
        report.mrConfigId = rawReportBody.substring(184, 48);
        report.mrOwner = rawReportBody.substring(232, 48);
        report.mrOwnerConfig = rawReportBody.substring(280, 48);
        report.rtMr0 = rawReportBody.substring(328, 48);
        report.rtMr1 = rawReportBody.substring(376, 48);
        report.rtMr2 = rawReportBody.substring(424, 48);
        report.rtMr3 = rawReportBody.substring(472, 48);
        report.reportData = rawReportBody.substring(520, ETHEREUM_PUBLIC_KEY_LENGTH);
    }

    /**
     * @notice Extracts the TEE-controlled address from the TD10ReportBody
     * @dev The Ethereum address is derived using the first 64 bytes of the reportData
     * @dev A core part of the flashtestation's protocol is that the TEE generates a TEE-controlled
     * address, which is used to identify the TEE in the AllowList. This address is derived
     * from the TEE's public key, which is included in the quote's reportData field
     * @param td10ReportBody The TD10ReportBody to extract the TEE-controlled address from
     * @return address TEE-controlled address
     */
    function extractEthereumAddress(TD10ReportBody memory td10ReportBody) internal pure returns (address) {
        if (td10ReportBody.reportData.length != ETHEREUM_PUBLIC_KEY_LENGTH) {
            revert InvalidReportDataLength(td10ReportBody.reportData.length);
        }
        return address(uint160(uint256(keccak256(td10ReportBody.reportData.substring(0, 64)))));
    }

    /**
     * @notice Derives the TEE's workloadId from the TD10ReportBody
     * @dev The workloadId is derived using the TEE's measurement registers
     * @param td10ReportBody The TD10ReportBody to extract the workloadId from
     * @return WorkloadId workloadId
     */
    function extractWorkloadId(TD10ReportBody memory td10ReportBody) internal pure returns (WorkloadId) {
        return WorkloadId.wrap(
            keccak256(
                abi.encode(
                    td10ReportBody.mrTd,
                    td10ReportBody.rtMr0,
                    td10ReportBody.rtMr1,
                    td10ReportBody.rtMr2,
                    td10ReportBody.rtMr3,
                    td10ReportBody.mrOwner,
                    td10ReportBody.mrOwnerConfig,
                    td10ReportBody.mrConfigId,
                    td10ReportBody.tdAttributes,
                    td10ReportBody.xFAM
                )
            )
        );
    }

    /**
     * Parses and checks that the uint16 version from the quote header is one we accept
     * @param rawReportBody The rawQuote bytes generated by Automata's verification logic
     * @dev Automata currently only supports V3 and V4 TDX quotes
     */
    function checkTEEVersion(bytes memory rawReportBody) internal pure {
        uint16 version = uint16(bytes2((rawReportBody.substring(0, 2)))); // uint16 is 2 bytes
        if (version != ACCEPTED_TDX_VERSION) {
            revert InvalidTEEVersion(version);
        }
    }

    /**
     * Parses and checks that the bytes4 tee type from the quote header is of type TDX
     * @param rawReportBody The rawQuote bytes generated by Automata's verification logic
     * @dev Automata currently only supports SGX and TDX TEE types
     */
    function checkTEEType(bytes memory rawReportBody) internal pure {
        bytes4 teeType = bytes4(rawReportBody.substring(2, 6)); // 4 bytes
        if (teeType != TDX_TEE) {
            revert InvalidTEEType(teeType);
        }
    }
}
