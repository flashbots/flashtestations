// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {TD10ReportBody} from "automata-dcap-attestation/contracts/types/V4Structs.sol";
import {BytesUtils} from "@automata-network/on-chain-pccs/utils/BytesUtils.sol";
import {TD_REPORT10_LENGTH, TDX_TEE, HEADER_LENGTH} from "automata-dcap-attestation/contracts/types/Constants.sol";

/**
 * @title QuoteParser
 * @dev A library for parsing and extracting workload and TEE-controlled address from Automata DCAP Attestation TDX quotes
 */
library QuoteParser {
    using BytesUtils for bytes;

    // Constants

    // The TDX version of the quote Flashtestation's accepts
    uint256 public constant ACCEPTED_TDX_VERSION = 4;

    // This is the number of bytes in the Output struct that come before the quoteBody.
    // See the Output struct definition in the Automata DCAP Attestation repo:
    // https://github.com/automata-network/automata-dcap-attestation/blob/evm-v1.0.0/evm/contracts/types/CommonStruct.sol#L113
    // 13 bytes = quoteVersion (2 bytes) + tee (4 byte) + tcbStatus (1 byte) + fmspcBytes (6 bytes)
    uint256 public constant SERIALIZED_OUTPUT_OFFSET = 13;

    // Errors

    error InvalidTEEType(bytes4 teeType);
    error InvalidTEEVersion(uint16 version);
    error InvalidQuoteLength(uint256 length);

    /**
     * @notice Parses the serialized output of the V4QuoteVerifier into a TD10ReportBody which contains
     * all the data we need for registering a TEE, using the serializedOutput bytes generated by Automata's
     * verification logic
     * @param serializedOutput The serializedOutput bytes generated by Automata's verification logic
     * @return report The parsed TD10ReportBody
     * @dev Taken from Automata's DCAP Attestation repo:
     * https://github.com/automata-network/automata-dcap-attestation/blob/evm-v1.0.0/evm/contracts/verifiers/V4QuoteVerifier.sol#L309
     */
    function parseV4VerifierOutput(bytes memory serializedOutput) internal pure returns (TD10ReportBody memory) {
        // check that now-verified quote is version 4 and of type TDX, otherwise
        // in the next step the output will not have the byte length we expect
        // and we'll fail to parse it, returning a unhelpful error message
        checkTEEVersion(serializedOutput);
        checkTEEType(serializedOutput);

        require(
            serializedOutput.length >= SERIALIZED_OUTPUT_OFFSET + TD_REPORT10_LENGTH,
            InvalidQuoteLength(serializedOutput.length)
        );

        return parseRawReportBody(serializedOutput.substring(SERIALIZED_OUTPUT_OFFSET, TD_REPORT10_LENGTH));
    }

    /**
     * @notice Parses a V4 TDX quote into a TD10ReportBody
     * @param rawV4Quote The raw V4 TDX quote
     * @return report The parsed TD10ReportBody
     */
    function parseV4Quote(bytes memory rawV4Quote) internal pure returns (TD10ReportBody memory) {
        require(rawV4Quote.length >= HEADER_LENGTH + TD_REPORT10_LENGTH, InvalidQuoteLength(rawV4Quote.length));
        return parseRawReportBody(rawV4Quote.substring(HEADER_LENGTH, TD_REPORT10_LENGTH));
    }

    /**
     * @notice Parses a raw report body into a TD10ReportBody
     * @param rawReportBody The raw report body
     * @return report The parsed TD10ReportBody
     * @dev Taken from Automata's DCAP Attestation repo:
     * https://github.com/automata-network/automata-dcap-attestation/blob/evm-v1.0.0/evm/contracts/verifiers/V4QuoteVerifier.sol#L309
     */
    function parseRawReportBody(bytes memory rawReportBody) internal pure returns (TD10ReportBody memory report) {
        report.teeTcbSvn = bytes16(rawReportBody.substring(0, 16));
        report.mrSeam = rawReportBody.substring(16, 48);
        report.mrsignerSeam = rawReportBody.substring(64, 48);
        report.seamAttributes = bytes8(rawReportBody.substring(112, 8));
        report.tdAttributes = bytes8(rawReportBody.substring(120, 8));
        report.xFAM = bytes8(rawReportBody.substring(128, 8));
        report.mrTd = rawReportBody.substring(136, 48);
        report.mrConfigId = rawReportBody.substring(184, 48);
        report.mrOwner = rawReportBody.substring(232, 48);
        report.mrOwnerConfig = rawReportBody.substring(280, 48);
        report.rtMr0 = rawReportBody.substring(328, 48);
        report.rtMr1 = rawReportBody.substring(376, 48);
        report.rtMr2 = rawReportBody.substring(424, 48);
        report.rtMr3 = rawReportBody.substring(472, 48);
        report.reportData = rawReportBody.substring(520, 64);
    }

    /**
     * Parses reportData to tee address and hash of extended report data
     */
    function parseReportData(bytes memory reportDataBytes)
        internal
        pure
        returns (address teeAddress, bytes32 extDataHash)
    {
        teeAddress = address(uint160(bytes20(reportDataBytes.substring(0, 20))));
        extDataHash = bytes32(reportDataBytes.substring(20, 32));
    }

    /**
     * Parses and checks that the uint16 version from the quote header is one we accept
     * @param rawReportBody The rawQuote bytes generated by Automata's verification logic
     * @dev Automata currently only supports V3 and V4 TDX quotes
     */
    function checkTEEVersion(bytes memory rawReportBody) internal pure {
        uint16 version = uint16(bytes2((rawReportBody.substring(0, 2)))); // uint16 is 2 bytes
        require(version == ACCEPTED_TDX_VERSION, InvalidTEEVersion(version));
    }

    /**
     * Parses and checks that the bytes4 tee type from the quote header is of type TDX
     * @param rawReportBody The rawQuote bytes generated by Automata's verification logic
     * @dev Automata currently only supports SGX and TDX TEE types
     */
    function checkTEEType(bytes memory rawReportBody) internal pure {
        bytes4 teeType = bytes4(rawReportBody.substring(2, 4)); // 4 bytes
        require(teeType == TDX_TEE, InvalidTEEType(teeType));
    }
}
