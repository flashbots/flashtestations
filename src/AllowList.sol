// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IAttestation} from "./interfaces/IAttestation.sol";
import {QuoteParser, WorkloadId} from "./utils/QuoteParser.sol";
import {TD10ReportBody} from "automata-dcap-attestation/contracts/types/V4Structs.sol";

// TEE identity and status tracking
struct RegisteredTEE {
    uint64 registeredAt; // The most recent timestamp that the TEE last registered with a valid quote
    WorkloadId workloadId; // The workloadID of the TEE device
    bytes rawQuote; // The raw quote from the TEE device, which is stored to allow for future quote re-verification
}

/**
 * @title AllowList
 * @dev A contract for managing trusted execution environment (TEE) identities and configurations
 * using Automata's Intel DCAP attestation
 */
contract AllowList {
    // Constants

    // Maximum size for byte arrays to prevent DoS attacks
    uint256 public constant MAX_BYTES_SIZE = 20 * 1024; // 20KB limit

    // Structs

    // Storage Variables

    // The address of the Automata DCAP Attestation contract, which verifies TEE quotes.
    // This is deployed by Automata, and once set on the AllowList, it cannot be changed
    IAttestation public attestationContract;

    // Used to track registered TEEs by the Ethereum address in the quote that originally registered them
    mapping(address => RegisteredTEE) public registeredTEEs;

    // Used to track registered TEEs by their (ethAddress, workloadId) pair,
    // which is needed for when
    mapping(WorkloadId => RegisteredTEE) public registeredTEEsByWorkloadId;

    // Events

    event TEEServiceRegistered(address ethAddress, WorkloadId workloadId, bytes rawQuote, bool alreadyExists);

    // Errors

    error InvalidQuote(bytes output);
    error ByteSizeExceeded(uint256 size);
    error TEEServiceAlreadyRegistered(address ethAddress, WorkloadId workloadId);

    /**
     * Constructor to set the the Automata DCAP Attestation contract, which verifies TEE quotes
     * @param _attestationContract The address of the attestation contract
     */
    constructor(address _attestationContract) {
        attestationContract = IAttestation(_attestationContract);
    }

    /**
     * @dev Modifier to check if input bytes size is within limits
     * to protect against DoS attacks
     */
    modifier limitBytesSize(bytes memory data) {
        require(data.length <= MAX_BYTES_SIZE, ByteSizeExceeded(data.length));
        _;
    }

    /**
     * @notice Registers a TEE workload with a specific Ethereum address in the AllowList
     * @notice The TEE must be registered with a quote whose validity is verified by the attestationContract
     * @dev In order to mitigate DoS attacks, the quote must be less than 20KB
     * @param rawQuote The raw quote from the TEE device. Must be a V4 TDX quote
     */
    function registerTEEService(bytes calldata rawQuote) external limitBytesSize(rawQuote) {
        (bool success, bytes memory output) = attestationContract.verifyAndAttestOnChain(rawQuote);

        if (!success) {
            revert InvalidQuote(output);
        }
        // at this point we know this quote was generated by an update-to-date TEE, but we still
        // need to make sure we can parse the workloadId and ethereum public key from the quote

        // now we can safely decode the output into the TDX report body, from which we can extract
        // the ethereum public key and compute the workloadID
        TD10ReportBody memory td10ReportBodyStruct = QuoteParser.parseTD10ReportBody(output);

        // extract the ethereum public key from the quote
        address ethAddress = QuoteParser.extractEthereumAddress(td10ReportBodyStruct);

        // extract the workloadId from the quote
        WorkloadId workloadId = QuoteParser.extractWorkloadId(td10ReportBodyStruct);

        // Register the address in the allowlist with the raw quote for future quote re-verification
        bool previouslyRegistered = addAddress(workloadId, ethAddress, rawQuote);

        emit TEEServiceRegistered(ethAddress, workloadId, rawQuote, previouslyRegistered);
    }

    /**
     * @notice Adds a TEE to the allowlist
     * @dev It's possible that a TEE has already registered with this ethereum address, but with a different workloadId.
     * This is expected if the TEE gets restarted or upgraded and generates a new workloadId.
     * It's also possible that the ethereum address and workloadId are the same, but the quote
     * is different. This is expected if Intel releases a new set of DCAP Endorsements (i.e.
     * a new TCB), in which case the quotes the TEE generates will be different.
     * In both cases, we need to update the allowlist with the new quote.
     * @param workloadId The workloadId of the TEE
     * @param ethAddress The Ethereum address of the TEE
     * @param rawQuote The raw quote from the TEE device
     * @return previouslyRegistered Whether the TEE was previously registered
     */
    function addAddress(WorkloadId workloadId, address ethAddress, bytes calldata rawQuote)
        internal
        returns (bool previouslyRegistered)
    {
        // check if the TEE is already registered with the same ethereum address and workloadId,
        // in which case this call is a no-op and possibly being called because of user error
        if (
            WorkloadId.unwrap(registeredTEEs[ethAddress].workloadId) == WorkloadId.unwrap(workloadId)
                && keccak256(registeredTEEs[ethAddress].rawQuote) == keccak256(rawQuote)
        ) {
            revert TEEServiceAlreadyRegistered(ethAddress, workloadId);
        }

        // this is a nice-to-have that signals to the user that the TEE was previously registered,
        // but it's not strictly necessary
        if (registeredTEEs[ethAddress].registeredAt > 0) {
            previouslyRegistered = true;
        }

        registeredTEEs[ethAddress] =
            RegisteredTEE({registeredAt: uint64(block.timestamp), workloadId: workloadId, rawQuote: rawQuote});
    }

    function verifyFlashestationTransaction(bytes memory attestationTransaction) external {
        // TODO: Implement
        // 1. check signature against live builder keys
        // 2. update liveness
    }
}
